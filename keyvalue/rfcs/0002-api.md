# RFC 0002: KeyValue API

**Status**: Draft

**Authors**:
- Jason Gustafson <12502538+hachikuji@users.noreply.github.com>

## Summary

This RFC defines the public API for KeyValue, providing `KeyValueDb` and `KeyValueDbReader` types that mirror the patterns established in existing OpenData systems.

## Motivation

RFC 0001 defined key encoding and storage semantics. This RFC completes KeyValue by defining the public interface for reading and writing data. The API follows patterns established in Log  and the other OpenData systems.

## Goals

- Define `KeyValueDb` as the main entry point for read and write operations
- Define `KeyValueDbReader` as a read-only view
- Define `KeyValueRead` trait for shared read operations
- Provide a minimal, curated API suitable for auxiliary storage needs

## Non-Goals

- Batch writes beyond atomic put/delete (deferred)
- Transactions or multi-key atomicity
- Range delete operations
- Merge operators or read-modify-write primitives

## Design

### Types

```rust
/// Main entry point providing read and write operations.
pub struct KeyValueDb { /* ... */ }

/// Read-only view of the key-value store.
pub struct KeyValueDbReader { /* ... */ }

/// Configuration for opening a KeyValueDb or KeyValueDbReader.
pub struct Config {
    pub storage: StorageConfig,
}
```

### KeyValueRead Trait

The `KeyValueRead` trait defines read operations shared by both `KeyValueDb` and `KeyValueDbReader`.

```rust
#[async_trait]
pub trait KeyValueRead {
    /// Gets the value for a key, or None if not found.
    async fn get(&self, key: Bytes) -> Result<Option<Bytes>>;

    /// Scans key-value pairs in lexicographic key order.
    ///
    /// Returns an iterator over entries whose keys fall within the range.
    /// Pass `..` to scan all entries.
    async fn scan(&self, key_range: impl RangeBounds<Bytes> + Send) -> Result<KeyValueIterator>;
}
```

### KeyValueDb

`KeyValueDb` provides both read and write operations.

```rust
impl KeyValueDb {
    /// Opens or creates a key-value store with the given configuration.
    pub async fn open(config: Config) -> Result<Self>;

    /// Puts a key-value pair, overwriting any existing value.
    pub async fn put(&self, key: Bytes, value: Bytes) -> Result<()>;

    /// Puts a key-value pair with custom options.
    pub async fn put_with_options(
        &self,
        key: Bytes,
        value: Bytes,
        options: WriteOptions,
    ) -> Result<()>;

    /// Deletes a key. No-op if key does not exist.
    pub async fn delete(&self, key: Bytes) -> Result<()>;

    /// Deletes a key with custom options.
    pub async fn delete_with_options(
        &self,
        key: Bytes,
        options: WriteOptions,
    ) -> Result<()>;

    /// Flushes pending writes to durable storage.
    pub async fn flush(&self) -> Result<()>;

    /// Closes the store, releasing resources.
    pub async fn close(self) -> Result<()>;
}

#[async_trait]
impl KeyValueRead for KeyValueDb { /* ... */ }
```

### KeyValueDbReader

`KeyValueDbReader` provides read-only access via the `KeyValueRead` trait.

```rust
impl KeyValueDbReader {
    /// Opens a read-only view of the key-value store.
    pub async fn open(config: Config) -> Result<Self>;
}

#[async_trait]
impl KeyValueRead for KeyValueDbReader { /* ... */ }
```

### Options

```rust
/// Options for write operations.
pub struct WriteOptions {
    /// If true, waits for the write to be durable before returning.
    /// Default: false (returns after write is applied to memtable).
    pub await_durable: bool,
}

impl Default for WriteOptions {
    fn default() -> Self {
        Self { await_durable: false }
    }
}
```

### Iterator

```rust
/// Iterator over key-value pairs.
pub struct KeyValueIterator { /* ... */ }

impl KeyValueIterator {
    /// Returns the next entry, or None if iteration is complete.
    pub async fn next(&mut self) -> Result<Option<KeyValueEntry>>;
}

/// A key-value entry returned by iteration.
pub struct KeyValueEntry {
    pub key: Bytes,
    pub value: Bytes,
}
```

### Thread Safety

Both `KeyValueDb` and `KeyValueDbReader` are `Send + Sync` and safe to share across threads. All methods take `&self`.

### Example Usage

```rust
use keyvalue::{KeyValueDb, KeyValueRead, Config};
use bytes::Bytes;

// Open a key-value store
let kv = KeyValueDb::open(config).await?;

// Write data
kv.put(Bytes::from("user:123"), Bytes::from("alice")).await?;
kv.put(Bytes::from("user:456"), Bytes::from("bob")).await?;

// Read data
let value = kv.get(Bytes::from("user:123")).await?;
assert_eq!(value, Some(Bytes::from("alice")));

// Scan a range
let mut iter = kv.scan(Bytes::from("user:")..Bytes::from("user;")).await?;
while let Some(entry) = iter.next().await? {
    println!("{}: {}", entry.key, entry.value);
}

// Delete data
kv.delete(Bytes::from("user:123")).await?;
```

## Alternatives

### Batch Write API

A batch API (`put_batch`, `delete_batch`) could improve throughput for bulk operations. This can be added later if usage patterns justify the complexity.

## Open Questions

None at this time.Ãš

## Updates

| Date       | Description |
|------------|-------------|
| 2026-02-03 | Initial draft |
